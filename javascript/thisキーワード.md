# thisキーワードについて

## 目次
- 実行コンテキスト
- コールスタック
- 関数コンテキストのthisの挙動
- アロー関数はthisを保持しない
- コールバック関数の場合のthisの挙動
- thisの束縛

## 実行コンテキスト
コードが実行される際に、Javascriptエンジンによって準備されるコードの実行環境のことらしい。  
スコープ内で宣言された変数や関数の情報や、thisの参照先などのコードを実行する際の保持情報って感じかな。  
コードが実行される直前と関数が実行される直前に生成される。  

### グローバルコンテキスト
コードが実行される前にまずグローバルコンテキストが生成される。  
グローバルコンテキストでは、  
- そのコンテキスト内で宣言された変数や関数
- this
- Windowオブジェクト  
が使用可能である。  
グローバルコンテキストでthisを使用する際の参照先はWindowオブジェクトになる  

### 関数コンテキスト
関数が実行される直前に関数コンテキストが生成される。  
関数コンテキストは、  
- そのコンテキスト内で宣言された変数や関数
- this
- arguments
- レキシカルスコープの変数や関数
- super  
が使用可能。  
関数コンテキストではWindowオブジェクトが存在しないが、レキシカルスコープの変数としてWindowオブジェクトを参照できる。  
WindowオブジェクトのプロパティにWindowオブジェクトの参照を保持しているから、他のすべてのスコープからWindowオブジェクトを参照できるようになっているってことかな。  

## コールスタック
実行コンテキストはコンテキスト内のコードの実行がすべて終了すると消滅するようになっているが、コンテキストのコードで新しいコンテキストが生成されたりして積みあがることをコールスタックっていうらしい。  
開発者ツールのソースからコールスタックを確認することで、  
どこからどのコードが呼び出されているかなどを確認できるから、デバッグとかに役立てることができるみたい。

## 関数コンテキストのthisの挙動
関数の実行の仕方によってthisの参照先が変わるみたい。  
ちなみにオブジェクトに関数を追加した場合はメソッドっといって、関数自体はメソッドとは呼ばないみたい。（あんまり厳密には知らなかった...）  
### 関数として実行した場合
関数として字こうした場合、thisの参照先はWindowオブジェクトになる。
```
window.name = "花子";
function() {
    console.log("こんにちは、"+ this.name);
}
hello(); //関数として実行
⇒こんにちは、花子
```
Strictモードってやつを有効にしたらthisの値がWindowオブジェクトではなくてundefinedになるらしい。

### メソッドとして実行した場合
メソッドとして実行した場合、呼び出し元のオブジェクトがthisの参照先になる
```
window.name = "花子";
const taro = {
    name:"太郎",
    hello: function(){
        console.log("こんにちは、"+ this.name)
    }
}
taro.hello(); //メソッドとして実行
⇒こんにちは、太郎
```
taroオブジェクトのメソッドで呼び出されたからtaroオブジェクトがthisの参照先になって太郎をつかっている。

## アロー関数はthisを保持しない
アロー関数はthisを保持しないため、レキシカルスコープにthisを探しに行く。  
レキシカルスコープにあるthisの参照先を見てthisを使うことはできる。  
↓実際に実行してないからちょっと違うかも  
```
window.name = "花子";
const taro = {
    name:"太郎",
    hello: () => {console.log("こんにちは、"+ this.name);} //レキシカルスコープのthisはWindowオブジェクト
}
taro.hello(); //メソッドとして実行
⇒こんにちは、花子
```

## コールバック関数の場合のthisの挙動
コールバック関数はあくまで関数として実行されるため、関数として実行した場合のthisの参照先としてWindowオブジェクトになる。
```
window.name = "花子";
const taro = {
    name:"太郎",
    hello: function(){
        console.log("こんにちは、"+ this.name)
    }
}
function fn(callback){
    callback();
}
fn(taro.hello); //taro.helloはメソッドだが、callbackはただの関数として実行されている。
⇒こんにちは、花子
```
オブジェクト.メソッド()という形式で実行されていない

## thisの束縛
前提として、アロー関数はthisを保持していないから束縛することはできない。  
- bindメソッド  
`const helloTaro = hello.bind(taro,"こんにちは");`  
thisの参照先をtaroに、引数として"こんにちは"を束縛させた関数を新しい関数として変数に代入している。  
thisの参照先と引数を束縛したいときに使用する    
- callメソッド  
bindメソッドと記述は変わらないが、新しい関数を作成して即時実行する。  
- applyメソッド  
引数を配列として渡すことができる。  
```
const vals = [1,2,3];
console.log(Math.max.apply(null,vals)); //thisは使用しないからnull渡してる
⇒3
```
スプレット演算子ってやつを使えば同じような実装をできるらしいから、あんまりapplyメソッドは使わないらしい。  
thisの束縛込みで使う場合はあるっぽいけど。
