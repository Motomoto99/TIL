# クラスについてまとめてみた

## 目次
- クラスの意味
- インスタンス化
- thisの参照先
- static
- get set
- クラスの継承
- 親クラスと子クラス
- プライベートなアクセス権
- プロトタイプ
- プロトタイプチェーン


## クラスの意味
クラスを定義することで、オブジェクトリテラルを使って毎回宣言しなくてよくなる。
```
class Person{
    constructor(name){ //コンストラクタの定義
        this.name = name;
    }
    Method(){  //メソッドの定義
        console.log(this.name);
    }
}
```

## インスタンス化
インスタンス化は、クラスを使ってオブジェクト（インスタンス）を作ったりすることをいうらしい。  
`const person = new Person("元ちゃん");`  
このインスタンスの中身は、`{name = "元ちゃん" , Method(){ console.log( this.name );} }`  
インスタンスは、クラス内のコンストラクタとかメソッドで定義した変数やメソッドそのものをプロパティとして使用できるっぽい。  
あんまりjavaと変わらないかな。フィールドとかは出てきてない。

## thisの参照先
thisの参照先は、呼び出し元のオブジェクトになる
```
person.Method();
⇒元ちゃん
```
personがメソッドとして実行しているのでthisの参照先はpersonのnameになる

## static
インスタンス化をせずにクラスから直接参照できる。
staticは静的って意味でクラスを定義するときにプロパティやメソッドの前につけることで、静的なプロパティやメソッドとして宣言することができる。  
```
class Person{
    static nameStatic = "元ちゃん"
    static Method(){  //メソッドの定義
        console.log(Persoh.nameStatic); //クラス名.プロパティで静的プロパティやメソッドにアクセスできる
    }
}
```
クラス名.メソッド名()の形式ではthisを使えない。
`this.constructor.nameStatic`
## get set
プロパティの値を変更したり参照したりするときに使うやつって感じ
```
class Person{
    constructor(name){ //コンストラクタの定義
        this.name = name;
    }
    Method(){  //メソッドの定義
        console.log(this.name);
    }
    get getter(){
        return this.name;
    }
    set nameSet(lastname){
        this._lastname = lastname;
    }
    get nameSet(){
        return this._lastname
    }
}

Person person = new Person(元ちゃん);
console.log(person.getter);
⇒元ちゃん
person.nameSet = "元々";
console.log(person.nameSet);
⇒元々
```
アンダースコアが変数の先頭についてるけど、それはクラス内のみの使用に制限していることを表しているらしい。
アンダースコアをつけたら何か機能が働くわけではなく、他の開発者ニクラス外から使用されないように示しているって感じかな。

## クラスの継承
これはJavaと同じで親クラスのプロパティやメソッドを継承した子クラスを生成できるってやつかな。  
クラスの継承によって冗長なコードを排除することができる。  
- 注意点
子クラスでコンストラクタを記述する場合、superをキーワードで親のコンストラクタを実行させないとエラーになる。  
superは一番最初に実行しないといけないっぽい。
superは親クラスを参照先に持ってるっぽくて、ドット記法で親クラスのプロパティやメソッドを参照できるみたい。

### 生成元クラスの確認
`let result = インスタンス instanceof クラス名;`
インスタンスが指定したクラス名を継承しているかを確認することができる。true、falseを返す
全てのクラスはObjectクラスを継承している。  

### hasOwnPropertyメソッドとin演算子
- hasOwnPropertyメソッド
プロパティ名が、自身のオブジェクトのプロパティや継承したクラスのプロパティに含まれていた場合にtrueを返す。  
`let result = オブジェクト.hasOwnProperty(プロパティ名);`
メソッド名が一致しただけではtrueを返さない。
- in演算子
オブジェクトが保持するプロパティまたはメソッドと一致した場合にtrueを返す。継承クラスに含まれていた場合も。
`let result = プロパティ名 in オブジェクト;`　　

## プライベートなアクセス権
「#」をプロパティの先頭に記述することでプライベートなアクセス権として設定することができる。  
プライベートなプロパティを使う場合は、クラスのトップレベルで宣言する必要がある。

## プロトタイプ
クラス記法ができる前に、クラスと同じような実装ができる仕組みって感じがした。
だから、クラスを理解する上で知っておくとより理解深まるよってことかな。
- コンストラクタ関数
コンストラクタ関数ってのを定義してインスタンスを生成するって感じかな。
一般的な関数とは違うから、区別するためにパスカルケース（先頭を大文字）にする。
```
function FunctionName(引数){
        this.プロパティ名 = 値;
}
```
コンストラクタ関数とクラスをまとめてコンストラクタっていうらしい。
- プロトタイプ
関数オブジェクトにprototypeプロパティが自動で設定される。
コンストラクタにはprototypeプロパティが設定してあって、コンストラクタを用いてインスタンスを生成すると、prototypeに格納されているオブジェクトへの参照を__proto__というプロパティにコピーする。
prototypeと__proto__は同じオブジェクトへの参照を保持しているから、prototypeのメソッドに対して行った変更はすべてのインスタンスに反映される。

## プロトタイプチェーン
- \_\_proto__
オブジェクトのプロパティを参照するときに、自身のオブジェクト内にプロパティが見つからなかった場合、暗黙的に__proto__オブジェクト内のプロパティやメソッドを探しにいく。
多分それを繰り返して探していくことができるからプロトタイプチェーンってことだろうな。
暗黙的に探しに行くから、ドット記法でプロパティやメソッドを記述するときは、__proto__をないものとして省略することができるってことだろうね。
`const obj = Object.create(protoObj);`
指定したオブジェクトへの参照を保持した__proto__が作成される。それを新しい変数に入れてるて感じか。

## プロトタイプ継承
`Chid.prototype = Object.create(Parent.prototype);`  
プロトタイプを継承している。  
クラスの継承的な感じなんかな？
もう少し深ぼることもできるけど、またプロトタイプが出てきたときに深ぼった方が、Javascriptに慣れてるからそっちの方がいいかも。
