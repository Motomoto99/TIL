# 非同期処理について

## 目次
- スレッド
- 非同期処理

## スレッド
スレッドは、プログラムの一連の処理の流れっていう感じで、JavaScriptは基本的に一つのスレッド（シングルスレッド）。  
ブラウザ上でJavaScriptのコードが実行されるスレッドは、メインスレッド。  
必ず実行中の処理が終了してから次の処理を実行するってのがシングルスレッドって感じかな。一つの処理が実行中の間は他の処理ができない。  
C/C++やjavaはマルチスレッド（並列処理）を実現できるらしい。  
- 同期処理  
このように、前の処理が終わってから次の処理を実行することを同期処理という。  
メインスレッド上で実行されるコードは必ず同期処理で実行される。

## 非同期処理
同期処理とは異なり、非同期処理は、前の処理が実行中でも他の処理を実行できる。  
要するに、前の処理が実行中でもメインスレッドを占有していない場合は、他の処理を実行することができるってことかな。  
setTimeoutは、引数で渡されたコールバック関数を引数で渡された秒数で実行するというのを予約だけ行って、コールバック関数の処理はメインスレッドから切り離される。  
なので、メインスレッドが占有されない。  
このように、setTimeoutやsetInterval、queueMicrotaskなどの関数は、ブラウザの非同期処理の機能を呼び出すためのAPIである。  

---
## イベントループ
- 実行コンテキスト  
コードの実行環境にある使えるデータって感じだったかな。thisとか  
- コールスタック  
実行コンテキストが積み重なったもの。  
- タスクキュー  
実行待ちのタスクが格納されたキューのこと。  
  
イベントループは、タスクキューに格納されたタスクを順番に実行していく仕組み。  
グローバルコンテキストがコールスタックに積まれてグローバルコンテキスト内のWebAPIなどがコールバック関数を予約してタスクキューに格納される。  
タスクキューはコールスタックが空になるまで実行を待機する。  
グローバルコンテキストが消滅するとコールスタックが空になるので、これをイベントループが検知して実行待ちのタスクをタスクキューから取り出して実行する。  
また、タスクキューから取り出された関数が実行されると関数コンテキストがコールスタックに積まれるので、他の実行待ちをしているタスクがイベントループによって取り出されるのは、関数コンテキストが消滅してからになる。  

- タスクソース  
タスクソースというカテゴリがあるらしい。
たとえば、ユーザの画面入力はユーザビリティに影響するため、他のタスクよりも優先して処理を行う、みたいにタスクのカテゴリによって処理を制御するみたい。
今はあまり意識はしなくていいかもしれないけど、何かWebアプリを作るときとかには少し確認してみるといいかも。

```
    setTimeout(() => {console.log("A")},1000)
    setTimeout(() => {console.log("B")})
    console.log("C")
  ⇒C　B　A
```
一秒待つ間に先にBの方がタスクキューに格納されたためAの後に書いてあるBが先にタスクキューから実行されたってことかな。  


